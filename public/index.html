<!DOCTYPE html>
<html>

<head>
  <title>Snake Paint</title>
  <style>
    canvas {
      border: 1px solid black;
      display: block;
      margin: 20px auto;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      background-color: #f0f0f0;
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Clear once at start
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let myId = null;

    socket.on('connect', () => {
      myId = socket.id;
    });

    function checkPixel(x, y, currentX, currentY) {
      // Make sure coordinates are within canvas bounds
      if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) return false;

      // Ignore checking the exact current position (where we're drawing)
      if (Math.abs(x - currentX) < 2 && Math.abs(y - currentY) < 2) return false;

      const pixel = ctx.getImageData(Math.round(x), Math.round(y), 1, 1).data;
      // Check if pixel is not white (indicating it's colored)
      return pixel[0] !== 255 || pixel[1] !== 255 || pixel[2] !== 255;
    }

    function checkCollision(player) {
      // Check current position (excluding self)
      const isOver = checkPixel(player.x, player.y, player.x, player.y);

      // Check ahead for intersections in a small arc
      const lookAhead = 3; // Distance to look ahead
      const angles = [-0.2, -0.1, 0, 0.1, 0.2]; // Check a small arc ahead
      let isAboutToHit = false;

      for (const angleOffset of angles) {
        const checkAngle = player.angle + angleOffset;
        const aheadX = player.x + Math.cos(checkAngle) * lookAhead;
        const aheadY = player.y + Math.sin(checkAngle) * lookAhead;

        if (!isOver && checkPixel(aheadX, aheadY, player.x, player.y)) {
          isAboutToHit = true;
          break;
        }
      }

      return {isAboutToHit, isOver};
    }

    socket.on('gameState', (gameState) => {
      const players = new Map(gameState);

      players.forEach((player, id) => {
        let color;
        if (id === myId) {
          const {isAboutToHit, isOver} = checkCollision(player);
          socket.emit('pixelState', {isAboutToHit, isOver});

          if (isOver) {
            color = '#00ff00'; // Green when over a trail
          } else if (isAboutToHit) {
            color = '#ffff00'; // Yellow when about to intersect
          } else {
            color = '#ff0000'; // Default red for current player
          }
        } else {
          if (player.is_over) {
            color = '#00ff00';
          } else if (player.is_about_to_hit) {
            color = '#ffff00';
          } else {
            color = '#0000ff'; // Default blue for other players
          }
        }

        // Draw the player
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(player.x, player.y, 2, 0, Math.PI * 2);
        ctx.fill();
      });
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        socket.emit('turn', -1);
      } else if (e.key === 'ArrowRight') {
        socket.emit('turn', 1);
      } else if (e.key === 'r') {
        // Reset canvas
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        socket.emit('turn', 0);
      }
    });
  </script>
</body>

</html>
